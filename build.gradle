import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    id 'java'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.3'
    id 'org.jetbrains.kotlin.jvm' version '2.3.0'
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(java_version)
    withSourcesJar()
    withJavadocJar()
}

// Quiet warnings about missing Javadocs.
javadoc {
    options.addStringOption('Xdoclint:-missing', '-quiet')
}

repositories {
    mavenCentral()
    maven() {
        url = uri("https://maven.hytale.com/${patchline}")
    }
    maven {
        url = uri("https://www.cursemaven.com")
    }
    mavenLocal()
}

dependencies {
    compileOnly "com.hypixel.hytale:Server:$hytale_version"
    compileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    // Load any dependencies in the libs folder
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "curse.maven:hyui-1431415:7516306"
}


// Create the working directory to run the server if it does not already exist.
def serverRunDir = file("$projectDir/run")
if (!serverRunDir.exists()) {
    serverRunDir.mkdirs()
}

// Updates the manifest.json file with the latest properties defined in the
// build.properties file. Currently we update the version and if packs are
// included with the plugin.
tasks.register('updatePluginManifest') {
    def manifestFile = file('src/main/resources/manifest.json')
    doLast {
        if (!manifestFile.exists()) {
            throw new GradleException("Could not find manifest.json at ${manifestFile.path}!")
        }
        def manifestJson = new JsonSlurper().parseText(manifestFile.text)
        manifestJson.Version = version
        manifestJson.IncludesAssetPack = includes_pack.toBoolean()
        manifestFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(manifestJson))
    }
}

// Makes sure the plugin manifest is up to date.
tasks.named('processResources') {
    dependsOn = ['updatePluginManifest']
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += ['-parameters']
}

tasks.withType(KotlinCompile).configureEach {
    compilerOptions {
        jvmTarget = JvmTarget.fromTarget(java_version.toString())
    }
}

tasks.withType(Javadoc).configureEach {
    onlyIf { fileTree("src/main/java").matching { include("**/*.java") }.files.size() > 0 }
}

tasks.named('javadoc') {
    enabled = false
}

sourceSets {
    main {
        java {
            srcDirs = ["src/main/java", "src/main/kotlin"]
        }
        resources {
            srcDirs = ["src/main/resources"]
            exclude ".idea/**"
        }
    }
    test {
        java {
            srcDirs = ["src/test/java", "src/test/kotlin"]
        }
        resources {
            srcDirs = ["src/test/resources"]
            exclude ".idea/**"
        }
    }
}

// Remove custom fatJar and revert to standard jar task
// Only include kotlin-stdlib in the JAR if needed
jar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from {
        configurations.runtimeClasspath.findAll { it.name.startsWith('kotlin-stdlib') }.collect { zipTree(it) }
    }
    exclude ".idea/**"
}

def mods_directory= project.hasProperty('mods_directory') ? file(project.property('mods_directory').toString()) : file("$projectDir/run/mods")

def autoCopyMod = project.hasProperty('auto_copy_mod') ? project.property('auto_copy_mod').toString().toBoolean() : false

tasks.register('copyJar', Copy) {
    onlyIf { autoCopyMod }
    dependsOn tasks.named('jar')
    from { tasks.named('jar').get().archiveFile.get().asFile }
    into { mods_directory }
    doFirst {
        println "Resolved `mods_directory` -> ${mods_directory.path}"
        if (!mods_directory.exists() || !mods_directory.isDirectory()) {
            throw new GradleException("Mods directory does not exist at ${mods_directory.path}")
        }
    }
    doLast {
        println "Copied ${tasks.named('jar').get().archiveFile.get().asFile.name} -> ${mods_directory.path}"
    }
}

if (autoCopyMod) {
    tasks.named('build') {
        finalizedBy tasks.named('copyJar')
    }
}
